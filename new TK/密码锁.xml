<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[密码锁]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[32]]></memory_limit>

<description><![CDATA[<p>
	玛雅人有一种密码，如果字符串中出现连续的2012四个数字就能解开密码。给一个长度为N的字符串，（2=&lt;N&lt;=13）该字符串中只含有0,1,2三种数字，问这个字符串要移位几次才能解开密码，每次只能移动相邻的两个数字。例如02120经过一次移位，可以得到20120,01220,02210,02102，其中20120符合要求，因此输出为1.如果无论移位多少次都解不开密码，输出-1。
</p>]]></description>
<input><![CDATA[<p>
	第一行输入N，第二行输入N个数字，只包含0，1，2
</p>]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[5
02120
5
02120]]></sample_input>
<sample_output><![CDATA[1
1]]></sample_output>
  <test_input><![CDATA[5
02120
7
0012020
2
20
10
2011011101
12
021012221101
10
1101102011
7
2220002
3
202
9
020201100
5
02111
2
21
11
21220021200
2
12
6
020021
3
102
7
0011110
9
002022120
10
0210021102
5
01010
10
0121210000
13
0121112200100
10
1102220101
2
20
9
210000212
7
1001000
4
2121
3
202
4
0120
12
102112011221
3
211
7
1010220
3
110
11
12201020002
11
00102100120
8
10020101
8
22002020
11
21122102222
2
11
3
111
13
0000201220000
6
100000
8
12021100
9
012012102
12
021212211121
4
1211
12
222201021200
2
10
7
0101012
10
0212120021
11
22121222212
2
21
5
11101
13
1222222222220
13
2211111111110
13
1000000000022
13
2221111111110
13
2122222222220
13
1222222222202
13
0222222222221
13
1222222222200
13
2121111111110
13
2211111111101
13
2211111111100
13
2200000000001
13
1200000000002
13
1122222222220
13
1221111111110
13
2112111111110
13
2111211111110
13
2111121111110
13
2111112111110
13
2111111211110
13
2111111121110
13
2111111112110
13
2111111111210
13
0111111111122
13
2111111111120
13
1100000000022
13
1020000000002
13
1002000000002
13
1000200000002
13
1000020000002
13
1000002000002
13
1000000200002
13
1000000020002
13
1000000000222
13
1000000002002
13
1000000000220
13
1000000000202
13
0100000000022
13
2222111111110
13
2212222222220
13
2212111111110
13
2221111111101
13
2221111111100
13
2220000000001
13
2112222222220
13
2122111111110
13
2211211111110
13
2211121111110
13
2211112111110
13
2211111211110]]></test_input>
<test_output><![CDATA[1
2
-1
-1
1
-1
-1
-1
2
-1
-1
1
-1
2
-1
-1
2
2
-1
2
3
2
-1
1
-1
-1
-1
-1
1
-1
3
-1
1
2
-1
-1
1
-1
-1
0
-1
1
0
1
-1
1
-1
-1
1
-1
-1
-1
12
12
12
11
11
11
11
11
11
11
11
11
11
11
11
11
11
11
11
11
11
11
11
11
11
11
11
11
11
11
11
11
11
11
11
11
11
11
10
10
10
10
10
10
10
10
10
10
10
10]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[名校复试机考真题-清华大学]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
#include<string.h>

int v[2000000],q[2000000];
int n;
int a[16];

int valid(int a[],int n) {
        int i;
        for(i=0;i+4<=n;i++)
                if (a[i]==2 && a[i+1]==0 && a[i+2]==1 && a[i+3]==2) return 1;
        return 0;
}

int trans1(int a[],int n) {
        int ret=0,i;
        for(i=0;i<n;i++) ret=ret*3+a[i];
        return ret;
}

void trans2(int a[],int n,int m) {
        int i;
        for(i=n-1;i>=0;i--) {
                a[i]=m%3;
                m/=3;
        }
}

int main() {
        char str[16];
        int i,j,t,m,tmp;
        memset(v,0xff,sizeof(v));
        while(scanf("%d",&n)!=EOF) {
                scanf("%s",str);
                for(i=0;i<n;i++) a[i]=str[i]-'0';
                m=trans1(a,n);
                v[m]=t=0,q[t++]=m;
                for(i=0;i<t;i++) {
                        trans2(a,n,q[i]);
                        if (valid(a,n)) break;
                        for(j=0;j<n-1;j++) {
                                tmp=a[j],a[j]=a[j+1],a[j+1]=tmp;
                                m=trans1(a,n);
                                if (v[m]<0) {
                                        v[m]=v[q[i]]+1;
                                        q[t++]=m;
                                }
                                tmp=a[j],a[j]=a[j+1],a[j+1]=tmp;
                        }
                }
                if (i<t) printf("%d\n",v[q[i]]); else puts("-1");
                for(i=0;i<t;i++) v[q[i]]=-1;
        }
        return 0;
}
]]></solution>
			<solution language="C++"><![CDATA[#include<stdio.h>
#include<string.h>

int v[2000000],q[2000000];
int n;
int a[16];

int valid(int a[],int n) {
	int i;
	for(i=0;i+4<=n;i++)
		if (a[i]==2 && a[i+1]==0 && a[i+2]==1 && a[i+3]==2) return 1;
	return 0;
}

int trans1(int a[],int n) {
	int ret=0,i;
	for(i=0;i<n;i++) ret=ret*3+a[i];
	return ret;
}

void trans2(int a[],int n,int m) {
	int i;
	for(i=n-1;i>=0;i--) {
		a[i]=m%3;
		m/=3;
	}
}

int main() {
	char str[16];
	int i,j,t,m,tmp;
	memset(v,0xff,sizeof(v));
	while(scanf("%d",&n)!=EOF) {
		scanf("%s",str);
		for(i=0;i<n;i++) a[i]=str[i]-'0';
		m=trans1(a,n);
		v[m]=t=0,q[t++]=m;
		for(i=0;i<t;i++) {
			trans2(a,n,q[i]);
			if (valid(a,n)) break;
			for(j=0;j<n-1;j++) {
				tmp=a[j],a[j]=a[j+1],a[j+1]=tmp;
				m=trans1(a,n);
				if (v[m]<0) {
					v[m]=v[q[i]]+1;
					q[t++]=m;
				}
				tmp=a[j],a[j]=a[j+1],a[j+1]=tmp;
			}
		}
		if (i<t) printf("%d\n",v[q[i]]); else puts("-1");
		for(i=0;i<t;i++) v[q[i]]=-1;
	}
	return 0;
}
]]></solution>
	</item>
</fps>
