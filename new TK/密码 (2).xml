<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[密码]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[16世纪法国外交家Blaise de Vigenère设计了一种多表密码加密算法——Vigenère密码。Vigenère密码的加密解密算法简单易用，且破译难度比较高，曾在美国南北战争中为南军所广泛使用。<br />
在密码学中，我们称需要加密的信息为明文，用M表示；称加密后的信息为密文，用C表示；而密钥是一种参数，是将明文转换为密文或将密文转换为明文的算法中 输入的数据，记为k。 在Vigenère密码中，密钥k是一个字母串，k=k1k2…kn。当明文M=m1m2…mn时，得到的密文C=c1c2…cn，其中ci= (mi-’A’+ki-’A’)mod26+’A’。<br />
Vigenere加密在操作时需要注意：<br />
1. 运算忽略参与运算的字母的大小写，并保持字母在明文M中的大小写形式；<br />
2. 当明文M的长度大于密钥k的长度时，将密钥k重复使用。<br />]]></description>
<input><![CDATA[输入包含多组测试数据<br />
输入共2行。<br />
第一行为一个字符串，表示密钥k，长度不超过100，其中仅包含大小写字母。第二行为一个字符串，表示经加密后的密文，长度不超过1000，其中仅包含大小写字母。<br />
对于100%的数据，输入的密钥的长度不超过100，输入的密文的长度不超过1000，且都仅包含英文字母。<br />]]></input> 
<output><![CDATA[输出共1行，一个字符串，表示输入密钥和密文所对应的明文。]]></output>
<sample_input><![CDATA[CompleteVictory
Yvqgpxaimmklongnzfwpvxmniytm]]></sample_input>
<sample_output><![CDATA[Wherethereisawillthereisaway]]></sample_output>
  <test_input><![CDATA[asdasdadasdadg
cxvjnisjdijiojsdaiojfoad
aas
dddd
a
sssd
d
xzzxcxzc
aasd
cvccvsdfdsfsd
]]></test_input>
<test_output><![CDATA[cfsjvfsgdqgildslxiwgflal
ddld
sssd
uwwuzuwz
cvkzvslcdsnpd
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[GZU]]></source>
		<solution language="C"><![CDATA[#include "stdio.h"
#include "string.h"


char m[1000], c[1000], k[1000];

char change(char ch,int i)
{
	char number,x,a,b;
	b = k[i];
	if ((ch >= 'a') && (ch <= 'z'))
	{
		a = 'a';
		if ((b >= 'A') && (b <= 'Z')) b = b - 'A' + 'a';
	}
	else a='A';


	number = ch - a;
	x = b - a;
	if (number < x) number = number + 26;
	number = number - x + a;
	return (number);
}

void work()
{
	int lengthc, lengthk, i, j,tag;
	lengthk = strlen(k);
	lengthc = strlen(c);
	tag = 0;
	for (i = 0; i <= lengthc; i++)
	{
		m[i] = change(c[i], tag);
		if (tag == lengthk-1) tag = 0;
		else tag++;
	}
	m[lengthc] = '\0';
	printf("%s\n", m);

}

void main()
{

	while (scanf("%s", &k) != EOF)
	{
		scanf("%s", &c);
		work();
	}

}]]></solution>
			<solution language="C++"><![CDATA[#include<stdio.h>
#include<string.h>
int main(){
	char c[1001],k[101];
	while(scanf("%s",k)!=EOF){
		  int all;
		  all=strlen(k);
		  scanf("%s",c);
		  int sum=0,t=0,ju=0;
		  while(c[t]!=NULL){
			  if(sum==all) sum=0;
			  if(c[t]<97) 
			  {ju=1;
			   c[t]=c[t]+32;
			  }//大写
			  else ju=0;//小写
			  for(int i=97;i<=122;i++){
				  if(k[sum]<97) k[sum]=k[sum]+32;  
				  if((i-97+k[sum]-97)%26+97==c[t]){
					  if(ju==0) printf("%c",i);
					  else printf("%c",i-32);
				  }  
			  }
			  t++;
			  sum++;
		  }
		  printf("\n");
	}
	return 0;
}]]></solution>
	</item>
</fps>
