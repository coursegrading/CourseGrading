<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[密码翻译]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[32]]></memory_limit>

<description><![CDATA[<p>
	在情报传递过程中，为了防止情报被截获，往往需要对情报用一定的方式加密，简单的加密算法虽然不足以完全避免情报被破译，但仍然能防止情报被轻易的识别。我们给出一种最简的的加密方法，对给定的一个字符串，把其中从a-y,A-Y的字母用其后继字母替代，把z和Z用a和A替代，则可得到一个简单的加密字符串。
</p>]]></description>
<input><![CDATA[<p>
	可能有多组测试数据。每组测试数据的第一行是字符串的数目n， (也要使用get(s)读取字符串,再用n=atoi(s)获得整数数值)，其余n行每行一个字符串,用gets(s)方式读取这一行字符串.每个字符串长度小于80个字符。
</p>]]></input> 
<output><![CDATA[<p>
	&nbsp;对于每组数据，输出每行字符串的加密字符串。
</p>]]></output>
<sample_input><![CDATA[2
fcaweygat5w4yw4yuh6w ytdnhsrth 
eTFWTY!@FE%^FEVCDHGD
]]></sample_input>
<sample_output><![CDATA[gdbxfzhbu5x4zx4zvi6x zueoitsui 
fUGXUZ!@GF%^GFWDEIHE
]]></sample_output>
  <test_input><![CDATA[10
fcaweygat5w4yw4yuh6w ytdnhsrth 
eTFWTY!@FE%^FEVCDHGD
gwthbfgbtgrs
jutr
hs
j
6w5
u
6w
uj7ec5tw56q6yw47)(*&^^&*(
]]></test_input>
<test_output><![CDATA[gdbxfzhbu5x4zx4zvi6x zueoitsui 
fUGXUZ!@GF%^GFWDEIHE
hxuicghcuhst
kvus
it
k
6x5
v
6x
vk7fd5ux56r6zx47)(*&^^&*(
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[名校复试机考真题-北京大学]]></source>
		<solution language="C"><![CDATA[int main(int argc, char* argv[])
{int n,len,i;
char s[81];
scanf("%d%*c",&n);
while(n--)
{
gets(s);
len=strlen(s);
for(i=0;i<len;i++)
{
if('a'<=s[i]&&s[i]<='y')s[i]+=1; 
else if('z'==s[i])s[i]='a';
if('A'<=s[i]&&s[i]<='Y')s[i]+=1;
else if('Z'==s[i])s[i]='A';
}
puts(s);
}
	return 0;
}
]]></solution>
			<solution language="C++"><![CDATA[/*AC*/
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<ctype.h>
int main()
{
        int n,i;
        char num[9],ss[81];
        while(gets(num))
        {
                n = atoi(num);
                while(n--)
                {
                        gets(ss);
                        for(i = 0;i < strlen(ss);i++)
                                if(isalpha(ss[i]))
                                {
                                        if(ss[i] == 'Z') ss[i] = 'A';
                                        else if(ss[i] == 'z') ss[i] = 'a';
                                        else ss[i] += 1;
                                }
                        puts(ss);
                }
        }
        return 0;
}]]></solution>
	</item>
</fps>
