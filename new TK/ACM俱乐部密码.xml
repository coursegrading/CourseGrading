<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[ACM俱乐部密码]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[32]]></memory_limit>

<description><![CDATA[<p>
	ACM俱乐部的墙上写着两行密码字符串，据说能破解其中奥秘的人计算机考研一定过。<br />
如果字符串一的所有字符按其在字符串中的顺序出现在另外一个字符串二中，则字符串一称之为字符串二的子串。注意，并不要求子串（字符串一）的字符必须连续出现在字符串二中。<br />
现在求ACM俱乐部两行密码字符串的最长公共子串的长度。
</p>]]></description>
<input><![CDATA[<p>
	每组测试数据输入两行，每行输入一个字符串（长度&lt;=100）。
</p>]]></input> 
<output><![CDATA[<p>
	每组测试数据输出一行，输出ACM俱乐部两行密码字符串的最长公共子串的长度。
</p>]]></output>
<sample_input><![CDATA[BDCABA
ABCBDAB
JXVTEWSNHACJDE
LDAAJNOPPERLJBPUUNHWSYYODMGW]]></sample_input>
<sample_output><![CDATA[4
5
]]></sample_output>
  <test_input><![CDATA[O
VP
JXVTEWSNHACJDE
LDAAJNOPPERLJBPUUNHWSYYODMGW
UVZZPKGHVAJCRB
X
HPRVSMFT
LYTCPKTPOJDFL
NZTIERMBSNDYDX
HLBZRDWVPEEV
ENTKHORTSMDJVANRLCYXO
MJWILHZHTOFTVKNX
Z
BNFVQRFV
CTIY
IDTVSPTGD
B
W
DOACLTR
BLFSHLGPNQENZSYEIE
LZCQCLYBXHFTKFQPLMPQWVQSOJETO
GEPSPJMCTPQRUDOWXPSBRZIOHEC
WTEICBQVOLKHMNDITIVYWSHYDBUNPYBWRICNFHXORCMJMUNJRNPKASCQWMTMJUOJYQEJDTYPAIBQDWWPSWADSQ
BEQIIJRUUNPUXDQKGDWBLO
OFICVDHUXUTPJW
WFGOZBCNLCG
GDDYCBBIXKLYVNVSKGANYKGPGRYLXAYPUODFJAKCRWBVRRUNRDRSUAWQSCOYBHDZQHXJ
FEGNXCXLCUEZUWFLATCKIZBGEGDQXYFUQRXLXRDQOKYOPNGKJAUFB
]]></test_input>
<test_output><![CDATA[0
5
0
2
3
6
0
1
0
1
8
13
2
18
]]></test_output>
<hint><![CDATA[<p>
	<br />
</p>]]></hint>
<source><![CDATA[剑指Offer]]></source>
		<solution language="C"><![CDATA[/*
 * =====================================================================================
 *
 *       Filename:  908.c
 *
 *    Description:  hahah LCS 
 *
 *        Version:  1.0
 *        Created:  2013/9/8 22:08:10
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  mdk-vim.cpp-c (mdk), mengdaikun@gmail.com
 *        Company:  cjluacm-vim-mdk
 *
 * =====================================================================================
 */
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#define MAX 100

int dp[MAX][MAX];

int max(int a, int b)
{
    return a > b ? a : b ;
}

int main()
{
    //freopen("a.in","r",stdin);
    
    char str1[MAX],str2[MAX];
    
    int i,j;

    int len1,len2;

    while(~scanf("%s %s",str1,str2))
    {
        
        len1 = strlen(str1);
        
        len2 = strlen(str2);

        for(i = 0 ; i <= len1 ; i++)
            
            dp[0][i] = 0;

        for(j = 0 ; j <= len2 ; j++)

            dp[j][0] = 0;

        for(j = 0 ; j < len1 ; j++)
        {
            for(i = 0 ; i < len2 ; i++)
            {
                if(str1[j] == str2[i])
                    dp[i+1][j+1] = dp[i][j]+1;
                else
                    dp[i+1][j+1] = max(dp[i][j+1],dp[i+1][j]);
            }
        }

        printf("%d\n",dp[len2][len1]);
    }

    return 0;
}

]]></solution>
			<solution language="C++"><![CDATA[#include <stdio.h>
#include <string.h>

// directions of LCS generation
enum decreaseDir {kInit = 0, kLeft, kUp, kLeftUp};
/////////////////////////////////////////////////////////////////////////////
// Get the length of two strings' LCSs, and print one of the LCSs
// Input: pStr1         - the first string
//        pStr2         - the second string
// Output: the length of two strings' LCSs
/////////////////////////////////////////////////////////////////////////////
int LCS(char* pStr1, char* pStr2)
{
      if(!pStr1 || !pStr2)
            return 0;

      size_t length1 = strlen(pStr1);
      size_t length2 = strlen(pStr2);
      if(!length1 || !length2)
            return 0;

      size_t i, j;

      // initiate the length matrix
      int **LCS_length;
      LCS_length = (int**)(new int[length1]);
      for(i = 0; i < length1; ++ i)
            LCS_length[i] = (int*)new int[length2];

      for(i = 0; i < length1; ++ i)
            for(j = 0; j < length2; ++ j)
                  LCS_length[i][j] = 0;

 

      // initiate the direction matrix
      int **LCS_direction;
      LCS_direction = (int**)(new int[length1]);
      for( i = 0; i < length1; ++ i)
            LCS_direction[i] = (int*)new int[length2];

      for(i = 0; i < length1; ++ i)
            for(j = 0; j < length2; ++ j)
                  LCS_direction[i][j] = kInit;

      for(i = 0; i < length1; ++ i)
      {
            for(j = 0; j < length2; ++ j)
            {
                  if(i == 0 || j == 0)
                  {
                        if(pStr1[i] == pStr2[j])
                        {
                              LCS_length[i][j] = 1;
                              LCS_direction[i][j] = kLeftUp;
                        }
                        else
                              LCS_length[i][j] = 0;
                  }
                  // a char of LCS is found, 
                  // it comes from the left up entry in the direction matrix
                  else if(pStr1[i] == pStr2[j])
                  {
                        LCS_length[i][j] = LCS_length[i - 1][j - 1] + 1;
                        LCS_direction[i][j] = kLeftUp;
                  }
                  // it comes from the up entry in the direction matrix
                  else if(LCS_length[i - 1][j] > LCS_length[i][j - 1])
                  {
                        LCS_length[i][j] = LCS_length[i - 1][j];
                        LCS_direction[i][j] = kUp;
                  }
                  // it comes from the left entry in the direction matrix
                  else
                  {
                        LCS_length[i][j] = LCS_length[i][j - 1];
                        LCS_direction[i][j] = kLeft;
                  }
            }
      }
      return LCS_length[length1 - 1][length2 - 1];
}

 

/////////////////////////////////////////////////////////////////////////////
// Print a LCS for two strings
// Input: LCS_direction - a 2d matrix which records the direction of 
//                        LCS generation
//        pStr1         - the first string
//        pStr2         - the second string
//        row           - the row index in the matrix LCS_direction
//        col           - the column index in the matrix LCS_direction
/////////////////////////////////////////////////////////////////////////////
int main()
{
	char a[100],b[100];
	while(scanf("%s%s",a,b)!=EOF)
		printf("%d\n",LCS(a,b));
	return 0;
} ]]></solution>
			<solution language="Pascal"><![CDATA[program t;
var s1,s2:ansistring;
    l1,l2,i,j:longint;
    c:array[0..100,0..100]of longint;
begin
 while not eof do
  begin
   readln(s1);
   readln(s2);
   l1:=length(s1);
   l2:=length(s2);
   fillchar(c,sizeof(c),0);
   for i:=1 to l1 do
    for j:=1 to l2 do
     if s1[i]=s2[j] then
      c[i,j]:=c[i-1,j-1]+1
     else
      if c[i-1,j]>c[i,j-1] then c[i,j]:=c[i-1,j] else c[i,j]:=c[i,j-1];
   writeln(c[l1,l2]);
  end;
end.]]></solution>
			<solution language="Java"><![CDATA[import java.util.*;
import java.io.*;
import java.math.*;


public class Main{
	
	public static Scanner cin=new Scanner(System.in);
	public static String a,b;
	public static int[][] dp;
	public static int lena,lenb;
	public static void main(String []args){
		while(cin.hasNext()){
			a=cin.next();
			b=cin.next();
			lena=a.length();
			lenb=b.length();
			dp=new int[lena][lenb];
			for(int i=0;i<lena;i++){
				for(int j=0;j<lenb;j++){
					if(i==0&&j==0){
						if(a.charAt(i)==b.charAt(j)){
							dp[i][j]=1;
						}else{
							dp[i][j]=0;
						}
					}else if(i==0){
						if(a.charAt(i)==b.charAt(j)){
							dp[i][j]=1;
						}else{
							dp[i][j]=dp[i][j-1];
						}
					}else if(j==0){
						if(a.charAt(i)==b.charAt(j)){
							dp[i][j]=1;
						}else{
							dp[i][j]=dp[i-1][j];
						}
					}else{
						if(a.charAt(i)==b.charAt(j)){
							dp[i][j]=dp[i-1][j-1]+1;
						}else{
							dp[i][j]=Math.max(dp[i-1][j], dp[i][j-1]);
						}
					}
				}
			}
			System.out.println(dp[lena-1][lenb-1]);
		}
	}
}]]></solution>
			<solution language="Python"><![CDATA[#coding=utf-8
def Matrix(rows,cols):
    matrix = [[[0,'#'] for col in range(cols+1)] for row in range(rows+1)]
    return matrix
def printf(lst,str1,str2):
    (rows,cols)=(len(str1),len(str2))
    print ' '*6,
    for tmp in str2:
        print '%s  ' % tmp,
    print
    print ' '*2,
    for j in range(cols+1):
            print '%d:%s' % (lst[0][j][0],lst[0][j][1]),
    print 
    for i in range(1,rows+1):
        print '%s ' % str1[i-1],
        for j in range(cols+1):
            print '%d:%s' % (lst[i][j][0],lst[i][j][1]),
        print
    

while True:
    x=raw_input()
    y=raw_input()
    (m,n)=(len(x),len(y))
    mat = Matrix(m,n)#已经经过初始化
    for i in range(1,m+1):
        for j in range(1,n+1):
            #print "i=%d,j=%d" %(i,j)
            if x[i-1]==y[j-1]:
                mat[i][j][0]=mat[i-1][j-1][0]+1
                mat[i][j][1]='↖'
            elif mat[i-1][j][0]>=mat[i][j-1][0]:
                mat[i][j][0]=mat[i-1][j][0]
                mat[i][j][1]='↑'
            else:
                mat[i][j][0]=mat[i][j-1][0]
                mat[i][j][1]='←'
    #printf(mat,x,y)
    print mat[m][n][0]
    
   
       
]]></solution>
			<solution language="C#"><![CDATA[using System;

namespace ACM密码
{
    class Class2149
    {
        static int[,] dp = new int[101, 101];
        static void Main()
        {
            string s;
            while((s=Console.ReadLine())!=null){
                string s1 = Console.ReadLine();
                for (int i = 0; i < 101; i++)
                    for (int j = 0; j < 101; j++)
                        dp[i, j] = 0;
                for (int i = 0; i < s.Length ; i++)
                    for (int j = 0; j < s1.Length ; j++)
                    {
                        if (s[i] == s1[j]) dp[i + 1, j + 1] = dp[i,j] + 1;
                        else if (dp[i + 1, j] > dp[i,j + 1]) dp[i + 1, j + 1] = dp[i + 1,j];
                        else dp[i + 1, j + 1] = dp[i,j + 1];
                    }
                Console.WriteLine(dp[s.Length, s1.Length]);
         //       for (int i = 0; i <= s.Length ; i++)
          //      {
           //         for (int j = 0; j <= s1.Length; j++)
            //            Console.Write(dp[i, j] + " ");
             //       Console.WriteLine();
              //  }

            }

        }
    }
}
]]></solution>
	</item>
</fps>
